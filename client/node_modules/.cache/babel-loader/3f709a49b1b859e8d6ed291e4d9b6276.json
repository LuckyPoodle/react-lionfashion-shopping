{"ast":null,"code":"import { createSelector } from 'reselect'; //get the WHOLE reducer state, and get a piece of it (shop)\n\nconst selectShop = state => state.shop;\n\nexport const selectCollections = createSelector([selectShop], shop => shop.collections);\nexport const selectCollectionsForPreview = createSelector([selectCollections], collections => collections ? Object.keys(collections).map(key => collections[key]) : [] //give us array of items we want\n);\nexport const selectCollection = collectionUrlParam => {\n  return createSelector([selectCollections], collections => {\n    console.log(collections);\n    return collections ? collections[collectionUrlParam] : null;\n  });\n};\nexport const selectIsCollectionFetching = createSelector( //we pass in selectShop as we want the shop object, then return shop.isFetching\n[selectShop], shop => shop.isFetching); //     CollectionUrlParam is a dynamic argument meaning it can change, so to memoize selectCollection we actually have to memoize the whole function using a memoize helper function.\n// By wrapping this function is memoize, we're saying that whenever this function gets called and receives collectionUrlParam, I want to memoize the return of this function (in this case we return a selector). If this function gets called again with the same collectionUrlParam, don't rerun this function because we'll return the same value as last time, which we've memoized so just return the selector that's been stored.","map":{"version":3,"sources":["C:/Users/ruiqu/myJavascript/lionfashion/client/src/redux/shop/shop.selector.js"],"names":["createSelector","selectShop","state","shop","selectCollections","collections","selectCollectionsForPreview","Object","keys","map","key","selectCollection","collectionUrlParam","console","log","selectIsCollectionFetching","isFetching"],"mappings":"AAAA,SAAQA,cAAR,QAA6B,UAA7B,C,CAGA;;AACA,MAAMC,UAAU,GAAEC,KAAD,IAASA,KAAK,CAACC,IAAhC;;AAEA,OAAO,MAAMC,iBAAiB,GAACJ,cAAc,CAGtC,CAACC,UAAD,CAHsC,EAIpCE,IAAD,IAAQA,IAAI,CAACE,WAJwB,CAAtC;AASP,OAAO,MAAMC,2BAA2B,GAACN,cAAc,CACnD,CAACI,iBAAD,CADmD,EAElDC,WAAD,IAAeA,WAAW,GAACE,MAAM,CAACC,IAAP,CAAYH,WAAZ,EAAyBI,GAAzB,CAA8BC,GAAD,IAAOL,WAAW,CAACK,GAAD,CAA/C,CAAD,GAAuD,EAF9B,CAGnD;AAHmD,CAAhD;AAKP,OAAO,MAAMC,gBAAgB,GAACC,kBAAkB,IAAE;AAG9C,SAASZ,cAAc,CAAC,CAACI,iBAAD,CAAD,EACnBC,WAAW,IAAE;AACTQ,IAAAA,OAAO,CAACC,GAAR,CAAYT,WAAZ;AACA,WAAQA,WAAW,GAACA,WAAW,CAACO,kBAAD,CAAZ,GAAiC,IAApD;AACH,GAJkB,CAAvB;AAMH,CATM;AAWP,OAAO,MAAMG,0BAA0B,GAAGf,cAAc,EACpD;AACA,CAACC,UAAD,CAFoD,EAGpDE,IAAI,IAAEA,IAAI,CAACa,UAHyC,CAAjD,C,CAYP;AACA","sourcesContent":["import {createSelector} from 'reselect';\r\n\r\n\r\n//get the WHOLE reducer state, and get a piece of it (shop)\r\nconst selectShop=(state)=>state.shop;\r\n\r\nexport const selectCollections=createSelector(\r\n\r\n \r\n       [selectShop],\r\n        (shop)=>shop.collections\r\n\r\n);\r\n\r\n\r\nexport const selectCollectionsForPreview=createSelector(\r\n    [selectCollections],\r\n    (collections)=>collections?Object.keys(collections).map((key)=>collections[key]):[]\r\n    //give us array of items we want\r\n)\r\nexport const selectCollection=collectionUrlParam=>{\r\n\r\n    \r\n    return   createSelector([selectCollections],\r\n        collections=>{\r\n            console.log(collections)\r\n            return((collections?collections[collectionUrlParam]:null))\r\n        }\r\n)\r\n}\r\n\r\nexport const selectIsCollectionFetching = createSelector(\r\n    //we pass in selectShop as we want the shop object, then return shop.isFetching\r\n    [selectShop],\r\n    shop=>shop.isFetching\r\n)\r\n   \r\n   \r\n      \r\n    \r\n\r\n \r\n\r\n//     CollectionUrlParam is a dynamic argument meaning it can change, so to memoize selectCollection we actually have to memoize the whole function using a memoize helper function.\r\n// By wrapping this function is memoize, we're saying that whenever this function gets called and receives collectionUrlParam, I want to memoize the return of this function (in this case we return a selector). If this function gets called again with the same collectionUrlParam, don't rerun this function because we'll return the same value as last time, which we've memoized so just return the selector that's been stored."]},"metadata":{},"sourceType":"module"}